sort1 uses: selection sort

How do you know?:
sort 1 on random5000 time = 0.107s
sort 1 on random10000 time = 0.322s
sort 1 on random50000 time = 7.452s

sort 1 on reversed5000 time = 0.094s
sort 1 on reversed10000 time = 0.276s
sort 1 on reversed50000 time = 5.419s

sort 1 on sorted5000 time = 0.047s
sort 1 on sorted10000 time = 0.064s
sort 1 on sorted50000 time = 0.331s

Scales very poorly with problem size if not sorted (random5000)
Linear relationship when going through sorted list
Has to check all n elements O(n)?
Very quick with sorted list as it only checks n elements? It starts searching from 1.

sort2 uses: bubble sort

How do you know?:
sort 2 on random5000 time = 0.033s
sort 2 on random10000 time = 0.085s
sort 2 on random50000 time = 0.382s

sort 2 on reversed5000 time = 0.049s
sort 2 on reversed10000 time = 0.069s
sort 2 on reversed50000 time = 0.432s

sort 2 on sorted5000 time = 0.045s
sort 2 on sorted10000 time = 0.063s
sort 2 on sorted50000 time = 0.519s

Seems to handle scaling problems very well O(log n)?
Very little difference if list is sorted or unsorted. Omega(log n)?

sort3 uses: merge sort

How do you know?:
sort 3 on random5000 time = 0.076s
sort 3 on random10000 time = 0.181s
sort 3 on random50000 time = 3.031s

sort 3 on reversed5000 time = 0.050s
sort 3 on reversed10000 time = 0.184s
sort 3 on reversed50000 time = 3.252s

sort 3 on sorted5000 time = 0.053s
sort 3 on sorted10000 time = 0.184s
sort 3 on sorted50000 time = 3.006s

Similar results across all 3 files
Faster that sort1 over large unsorted samples
However over sorted samples still has the same time relationship.